---
layout: post
title: Task and async in C#
description: Task Parallel Library and async programming in C#
published: true
---
Let's explore various aspects of C# programming through different code examples.

## 1. Parallel Processing with Task Parallel Library (TPL)

The first example demonstrates parallel processing using TPL:

```csharp
ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = 10 };
Parallel.For(0, 10, options, i =>
{
    // Parallel processing code here
});

// Resource-intensive computation
static void ResourceIntensiveFunction()
{
    double result = 0;
    for (int i = 0; i < 1000000000; i++)
    {
        result += Math.Sqrt(i);
    }
}
```

This code shows how to limit parallel processing to 10 threads and measure performance using `Stopwatch`.

## 2. Delegates in C#

Here's an example of using delegates for method invocation:

```csharp
public delegate int Operation(int a, int b);

public static int Add(int a, int b) => a + b;
public static int Multiply(int a, int b) => a * b;

public static void PerformOperation(int a, int b, Operation operation)
{
    int result = operation(a, b);
    Console.WriteLine("Result: " + result);
}
```

Delegates provide a way to pass methods as parameters, enabling flexible and reusable code.

## 3. Unicode Output in Console

Console applications can display Unicode characters:

```csharp
Console.OutputEncoding = System.Text.Encoding.Unicode;
Console.WriteLine("\u2304");        // âŒ„
Console.WriteLine("\U0001F4AF");    // ðŸ’¯
Console.WriteLine("\U0001F604");    // ðŸ˜„
```

Setting proper encoding ensures correct display of Unicode characters.

## 4. Asynchronous Matrix Operations

This example shows parallel matrix computations:

```csharp
static async Task Main()
{
    const int N = 10000;
    Task[] tasks = new Task[4];
    for (int i = 0; i < 4; i++)
    {
        tasks[i] = Task.Run(() => ComputeMatrixInverse(N));
    }
    await Task.WhenAll(tasks);
}
```

The code demonstrates parallel matrix operations using Tasks for improved performance.

## 5. Task and Thread Management

Here's an example of task and thread management:

```csharp
Task singleTask = Task.Run(() => {
    Console.WriteLine($"Single task on thread {Thread.CurrentThread.ManagedThreadId}");
    Thread.Sleep(2000);
});

Parallel.For(0, 4, i => {
    Console.WriteLine($"Parallel {i} on thread {Thread.CurrentThread.ManagedThreadId}");
    Thread.Sleep(2000);
});
```

This demonstrates different ways to handle concurrent operations in C#.

## 6. Timer Implementation

Finally, a timer example:

```csharp
private static System.Timers.Timer aTimer;

private static void SetTimer()
{
    aTimer = new System.Timers.Timer(2000);
    aTimer.Elapsed += OnTimedEvent;
    aTimer.AutoReset = true;
    aTimer.Enabled = true;
}
```

This shows how to implement recurring events using Timer in C#.

Each of these examples demonstrates different aspects of C# programming, from basic concepts to advanced parallel processing techniques. The code samples provide practical implementations that can be used as building blocks for larger applications.


# `volatile` Keyword 
## Why `volatile` is Useful

In multi-threaded applications, threads may cache variables in their local memory, leading to inconsistencies when the variable is updated by another thread. The `volatile` keyword prevents such caching, ensuring that the variable is always read from the main memory, thus maintaining data consistency across threads.

## How `volatile` is Used

To use the `volatile` keyword, simply declare the field with the `volatile` modifier. For example:

```csharp
private volatile bool keepRunning = true;
```

In the provided code, `keepRunning` is marked as `volatile` to ensure that changes made by one thread (e.g., the `Stop` method) are immediately visible to other threads (e.g., the `Worker` method).

## When to Use `volatile`

- When a field is accessed by multiple threads without using locks.
- When you need to ensure that the most recent value of a field is always read by all threads.

## When Not to Use `volatile`

- When more complex synchronization is required (e.g., atomic operations, multiple fields).
- When you need to perform compound operations (e.g., incrementing a counter) that must be atomic.
- When the field is not accessed by multiple threads.

In such cases, other synchronization mechanisms like `lock`, `Monitor`, or `Interlocked` should be used to ensure thread safety.

```csharp

using System;
using System.Threading;

public class VolatileExample
{
    private volatile bool keepRunning = true;

    public void Start()
    {
        Thread workerThread = new Thread(Worker);
        workerThread.Start();
    }

    private void Worker()
    {
        while (keepRunning)
        {
            Console.WriteLine("Working...");
            Thread.Sleep(1000); // Simulate work
        }
        Console.WriteLine("Stopped working.");
    }

    public void Stop()
    {
        keepRunning = false;
    }

    public static void Main()
    {
        VolatileExample example = new VolatileExample();
        example.Start();

        // Simulate some work, then stop the worker thread
        Thread.Sleep(5000); // Let it run for 5 seconds
        example.Stop();
    }
}

```
